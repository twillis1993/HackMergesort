# The assembly program

The program `mergesortFunction.asm` contains a mergesort function. It also contains auxiliary functions to merge arrays, copy them, and carry out integer division. Other than the first few lines, which invoke the mergesort function and provide a loop in which the program terminates, the program is structured as a function. This means that the mergesort routine expects its arguments to be present on the stack at the time of its invocation. The test scripts generated by the Python script `generateTestScript.py` will push the necessary arguments onto the stack before launching the program. This is more elegant than the inclusion of Hack code at the beginnning of the file to set up the stack and also makes the file modular: the mergesort source code could be copied into another file for use as a function in its own right. This also makes possible the `generateTestScript.py`, with which a user can specify an arbitrary list of numbers to sort and produce a `tst` testing script which will load the input into the emulator and launch the mergesort program.

NB: As explained below, the test scripts terminate execution with a breakpoint when the program counter (PC) reaches 3. This removes the need to estimate the number of clock cycles required in advance and means that the emulator can be run without animation to move directly to the state of the machine at the termination of the program.

# Largest possible instance

Using the `generateTestScript.py` program, I tested an instance of size 9500. The program was able to sort this successfully. The instance of size 9600 failed due to the size limitation of the emulator's RAM. I surmise that the maximum instance size lies between 9500 and 9599, inclusive.

# Virtual registers

The first 15 words of RAM are reserved as virtual registers which provide local storage for functions. The first word of RAM at address 0 is a special register: it acts as the stack pointer, i.e. the pointer to the current top of the stack.

Not all of the virtual registers are used; only the first nine words of RAM are in use as virtual registers.

# The stack

Function arguments are managed using a stack. The base of the stack is always address 100, although arguments are pushed to RAM addresses 101 and above, such that cell 100 is never used. The cell at RAM address 0 acts as the stack pointer, storing the address of the top of the stack at any moment.

One pushes arguments onto the stack by incrementing the stack pointer and writing the value of the argument to the address to which the stack pointer points. The example below shows a value stored at RAM address 3 (a virtual register) being pushed onto the stack:

	// Push function return address (in R3)
	@0
	M=M+1
	@3
	D=M
	@0
	A=M
	M=D

One pops arguments by saving the value of the top of the stack in RAM and decrementing the stack pointer. The example below shows a value being popped from the stack and stored at RAM address 1 (a virtual register):

	// Save length of array in R1
	@0
	A=M
	D=M
	@1
	M=D
	@0
	M=M-1	

# Reserved memory

I list the areas of memory used by the program:

* The first 15 words of RAM are used as virtual memory
* The stack begins at RAM address 100 and grows upwards into higher memory
* Merge copies its two input arrays to areas of memory starting at RAM addresses 5000 and 10000, respectively
* `generateTestScript.py` will write the input to the area of memory beginning at RAM address 15000

I chose this layout in order to maximise the size of the largest possible instance.

# Using the test script generator and test scripts

`generateTestScript.py` is a Python script which generates `tst` scripts. `tst` scripts can be loaded into the Hack CPU emulator by clicking on the script button (to the left of the breakpoint flag icon). `tst` scripts will load the assembly code into ROM, configure the RAM with input values, and execute the program. This Python script generates `tst` scripts which have as their breakpoint a program counter (PC) value of 3, which corresponds to the `END` location in `mergesortFunction.asm`. Please remember to clear the RAM if running these scripts in succession (I could not find an option in the `tst` language to clear all the RAM).

`generateTestScript.py` requires at minimum a list of integers to sort, which are passed after the `-i` flag, OR a single integer from the interval 1 to 1000, passed with the `-n` flag. The latter specifies the size of a list of random integers to generate, taken from the interval [-100, 100]. `-i` and `-n` are mutually exclusive arguments.

Run `generateTestScript.py` with `-h` to print usage guidance.

Additionally, with the `-A` one can specify the name of an assembly file to load in the script. With the `-O`, one can also specify the name of the test script to be written out.

## Verifying the output of the Assembly program after launching with a test script

The test script generator writes test scripts which specify as the location of the input array RAM address 15000. The output will also be written to this address, i.e. the mergesort will sort its input 'in-place' (although the algorithm is not a true in-place mergesort as it uses auxiliary arrays in the `merge` subroutine). There is no need to manually enter the input at this address: the test script will load the specified list of numbers, or the randomly generated list of numbers, into a range of RAM addresses beginning at 15000.
