Clear registers before use rather than en masse

Use to push return address onto stack
@RET
D=A
@0
M=M+1
A=M
M=D

Should choose 1000 as base of stack

# Mergesort pseudocode

Push return address, address of first array element, and length onto stack.

If length is 1, return. If not, call merge on mergesorted halves of array. 

Write integer divide subroutine and call this to determine half length.

# Merge pseudocode (could write separately)

Args: return address, address of first element of first half, length of first half, address of first element of second array, length of second half.

Copy two halves of array to free memory e.g starting at 10000 and 11000. Then while loop to overwrite input memory, starting from address of first element of first half. 

Could have array copy routine. 

# Copy pseudocode:

Needs args: return address, address of first element, length of array, destination address.

Pop off arguments into virtual registers 1-4. 

Increment address of first element, decrement length, increment destination address each loop

While loop:
(WHILE)
@3
D=M
@COPY_E
D; JMP
// loop body
@2
D=M
@4
M=D
@2
M=M+1
@4
M=M+1
@3
M=M-1
@WHILE
0; JMP

@1
A=M
0; JMP

Division pseudocode

Args: return address, dividend, divisor

Clear and set virtual registers

Set R4 to 0, quotient

(DIV_LOOP)
@2
D=M
@3
D=D-M
@DIV_E
D; JLT
@2
M=D
@4
M=M+1
@DIV_LOOP
0; JMP
(DIV_END)
@4
D=M
@1
A=M
0; JMP

Debugging: copying arguments to virtual registers correctly.
